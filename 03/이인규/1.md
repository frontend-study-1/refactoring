## 기능 이동

## 8.1 함수 옮기기

- 함수가 참조하는 데이터들과 가까이 위치하도록, 함수의 선언위치를 변경시키는 것을 의미합니다.
- 하나의 클래스에서 다른 클래스로 메소드를 이동시키는 것을 생각할 수 있습니다.

## 8.2 필드 옮기기

- 함수 옮기기와 마찬가지로, 변수의 선언 위치를 이동시키는 리팩토링을 말합니다.

## 8.3 문장을 함수로 옮기기

- 어떤 구문이, 특정 함수와 항상 같은 패턴으로 사용된다면 해당 구문을 함수와 병합시킬 수 있습니다.
- 어차피 하나처럼 코드가 작성될 거라면, 굳이 분리해서 코드를 작성할 필요가 없습니다.
- 만약 항상 같이 사용되는 것이 아니라면, 원하는 케이스만 분리하여 새로운 함수를 선언하는 방법도 사용할 수 있을 것입니다.

## 8.4 문장을 호출한 곳으로 옮기기

- 8.3 문장을 함수로 옮기기의 반대되는 작업입니다.
- 특정 경우에 따라, 이미 캡슐화된 함수의 특정 부분이 바뀌어서 실행되어야 한다면 해당 구문을 함수로부터 추출할 수 있습니다.

## 8.5 인라인 코드를 함수 호출로 바꾸기

- `for` 반복문을 사용하지 않고 `forEach`나 `map`을 사용한다면 이 리팩토링을 잘 사용하고 있다고 볼 수 있습니다.
- `for` 키워드를 이용한 반복문은 동작을 인라인으로 작성하게 하는데, `forEach`, `map`, `filter`같은 함수들을 이용하면 자연스럽게 인라인 코드를 함수 호출 형식으로 바꾸어 작성하게 됩니다.

## 8.6 문장 슬라이드하기

- 공통적인 동작을 하는 코드 구문들을 한 데 모아놓는 개념입니다.
- 여기서의 공통적인 동작이란, 실제 코드 구문이 같은 것 외에도  
  문맥 상 같은 동작들(변수 선언, 함수 실행)을 하는 것도 포함합니다.
- 공통 도메인의 변수들을 모아 선언하는 데도 사용할 수 있을 것 같은데, 변수 선언 순서에 따라 로직이 변하지 않게 주의해야 합니다.

## 8.7 반복문 쪼개기

- 반복문 하나에서 여러 가지 일을 실행할 때, 반복문 하나에서는 하나의 기능만 수행하도록  
  반복문을 중복 작성하는 리팩토링입니다.
- 1회 순회로 동작할 수 있는 코드를 2회 순회 형식으로 바꾸는 것이기 때문에, 반복문 쪼개기 이전의 코드와  
  성능 상의 차이가 발생할 수는 있습니다.
- 다만 **최적화**와 **리팩터링**을 구분해야 한다고 합니다.
- 반복문 쪼개기를 우선은 시도해 보고, 실제로 프로그램에 문제가 되는 수준의 성능 차이가 난다면 그 때에 고민할 문제라고 합니다.
- 반복문을 쪼개 하나의 반복문에서는 하나의 기능만 수행하게 하면, 단일 책임 원칙이 적용되며 "함수 추출하기"를 적용할 수도 있습니다.

## 8.8 반복문을 파이프라인으로 바꾸기

- 8.5에서도 언급한 `map`, `forEach`, `filter`와 같은 함수들을 이용한 리팩토링입니다.
- for 반복문을 사용하지 않고도 컬렉션 데이터를 순회할 수 있으며, 함수 체이닝을 이용하여 작업의 순서가 명확하게 코드에 표현됩니다.

## 8.9 죽은 코드 제거하기

- 사용하지 않는 코드를 제거하는, 단순한 리팩토링입니다.
- 이전 기능을 대체할 새로운 코드를 추가하며, 이전 코드를 그대로 방치하게 되는 경우가 있을 수 있는데,  
  이는 프로그램의 동작에는 영향을 미치지 않지만, 프로그램을 이해하는 데 방해가 될 수 있기 때문에 제거하는 것이 좋습니다.
