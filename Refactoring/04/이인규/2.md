## API 리팩터링

### 11.1 질의 함수와 변경 함수 분리하기

- 질의 함수(query), 데이터를 가져오는 함수는 데이터를 변경하는 등의 부수 효과가 없어야 합니다.
- 기본적으로 데이터를 가져오는 한 개의 기능을 제외한 어떤 작업을 하게 된다면, 단일 책임 원칙부터가 지켜지지 않게 됩니다.
- 그리고 데이터를 가져옴과 동시에 변조하게 되는데, 그 내용이 데이터를 가져오는 부분과 혼합된다면 서버에서 가져온 데이터가 어떤 형태인지 추적하기가 어려워집니다.

### 11.2 함수 매개변수화하기

- 서로 다른 부분에서 동작하는 코드가, 특정 리터럴 값만을 제외하고 나머지가 동일하다면
- 해당 "특정 리터럴 값"을 인자로 받는 하나의 함수로 통합하여 작성할 수 있습니다.

### 11.3 플래그 인수 제거하기

- 함수의 입력값을 통해서 분기가 발생하는 구조가 있다면, 그냥 입력값 각각에 대한 함수를 따로 구현하는 것이 더 나을 수 있는가에 대해 생각을 해 보아야 합니다.
- 예제로 대신합니다.

```javascript
const setDimensions = (name, value) => {
	if (name === 'height') this._height = value;
	if (name === 'width') this._width = value;
}

...

const setHeight = (value) => this._height = value;
const setWidth = (value) => this._width = value;
```

### 11.4 객체 통째로 넘기기

- 하나의 객체에 있는 여러 값을 인자로 받는 함수가 있다면, 인자로 객체를 통째로 전달하는 방법을 고려해도 좋습니다.
- 데이터가 하나의 함수로 입력된다는 것은, 같은 도메인의 데이터이기 때문이라고 볼 수 있기 때문에 객체 형태로 데이터를 전달하는 것이 코드를 이해하기에도, 작성하기에도 편리하게 됩니다.

### 11.5 매개변수를 질의 함수로 바꾸기

- 예시로 대신합니다. "객체 통째로 넘기기"와 비슷해 보이는데?

```javascript
availableVacation(anEmployee, anEmployee.grade);

...

availableVacation(anEmployee);
```

### 11.6 질의 함수를 매개변수로 바꾸기

- 11.5 와 반대되는 개념입니다.
- 인자로 받지 않은 변수를 함수 내에서 참조한다면, 부수 효과를 발생시킬 수 있기 때문에 매개변수로 전달받을 수 있도록 분리하는 것이 좋습니다.

### 11.7 세터 제거하기

- 불변을 유지해야 하는 멤버에 대해서는, 기본 정의된 setter함수를 overwrite하여 값의 대입을 명시적으로 막을 수 있습니다.

### 11.8 생성자를 팩토리 함수로 바꾸기

- 생성자를 만드는 구문(`new MyClass(...)`)를 대신 실행해 주는, 팩토리 함수로 작성할 수 있습니다.
- 특정 구문에서 생성자에 들어가는 요소가 공통이 되는 부분이 있다면, 공통이 되는 인자들을 일괄로 처리할 수 있도록 팩토리 함수를 정의하는 것이 도움이 될 수 있습니다.

### 11.9 함수를 명령으로 바꾸기

- 인자를 입력받아, 어떤 로직을 진행하는 함수를
- 생성자를 통해 초기값을 입력받고, 객체 메소드로 로직을 실행하는 객체 형태로 바꿀 수가 있습니다.

### 11.10 명령을 함수로 바꾸기

- 인자의 수가 몇 개 되지 않고, 로직 자체가 복잡하지 않다면 굳이 객체 구조를 고수할 필요는 없습니다.
- 단순 인자를 입력받아 로직을 실행하는 함수 하나로 작성할 수가 있습니다.

### 11.11 수정된 값 반환하기

- 함수 바깥에 있는 변수에 접근하여, 그 데이터를 변경하는 코드는 매우 위험할 수 있습니다.
- 명확하게 어떤 함수가 어디에 이용되는지 추적하기 어렵기 때문에, 부득이하게 인자로 전달받지 않은 변수에 접근하게 되는 경우에는
- 원본 값을 덮어씌우는 방식이 아니라, 새로운 임시 변수를 만들어 그 안에 연산 결과를 담아 함수에서 반환하게 하는 것이 적절합니다.

### 11.12 오류 코드를 예외로 바꾸기

- 서버와의 통신에는 많은 에러 상황이 발생할 수 있습니다.
- 서버와의 통신이 아니여도 클라이언트 정책 상 발생할 수 있는, 우리가 알고 있는 오류에 대해서 처리가 필요할 때가 있습니다.
- 이럴 때에는 단순히 정의된 에러 코드를 반환한다거나 하는 방식만 사용하는게 아니라, `throw`키워드를 이용하여 명시적으로 에러를 발생하는 것이 좋습니다.
- 단순 값 반환으로만 처리된다면 앱의 에러 발생을 추적하기가 어려워집니다. 부수효과를 찾기 어려워진다는 뜻이 되겠네요

### 11.13 예외를 사전확인으로 바꾸기

- 연산하려는 데이터가 null이거나, 배열의 길이를 벗어난 인덱스를 접근하려고 하는 등의 에러가 있을 수 있는 코드가 있을 수 있습니다.
- 이런 경우에는 모든 경우를 `try-catch`로 예외처리하지 않고, null 체크나, 배열 길이 체크 등을 미리 로직에 포함시켜 에러가 발생할 수 있는 코드 자체를 회피할 수 있습니다.
