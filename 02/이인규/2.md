## 캡슐화

## 7.1 레코드 캡슐화하기

- [1.md](./1.md)에서 확인한 **변수 캡슐화하기** 와 유사한 개념입니다.
- 특히 여기에서는 클래스 형태로 데이터를 전환할 것을 예시로 들고 있습니다.
- 클래스로 변수를 캡슐화하면, `getter`와 `setter`를 클래스를 통해서 정의하여  
  데이터에 대한 접근을 개발자가 제어할 수 있습니다. 캡슐화의 의미가 더 강하다고 볼 수 있습니다.

## 7.2 컬렉션 캡슐화하기

- 클래스 변수가 List나, Object, 또는 Set과 같은 컬렉션 데이터라면  
  클래스의 `setter`나, `getter`를 통한 접근 제한으로는 데이터 변경을 완벽히 제어할 수가 없습니다.
- 특히 `getter`가 컬렉션 자체를 그대로 반환한다면, 클래스가 알지 못하는 사이에 데이터가 변경될 수도 있습니다.
- 그래서 컬렉션을 조작하는 작업들을 별도의 함수로 선언하여, 해당 함수 로직을 통해서만 값에 접근할 수 있게 해야 합니다.
- 대표적으로 array 데이터에는 `push`나, `pop`함수로 데이터를 제어하도록 함수가 제공되어 있습니다.  
  실제로 array를 개발자 마음대로 조절할 수는 있지만, 만약 우리가 컬렉션 데이터를 관리하는 클래스를 따로 만든다면 push, pop 이외의  
  다른 접근을 할 수 없도록 제한을 하게 되겠죠?

## 기본형을 객체로 바꾸기

- 흠..
- 단순 기본형으로만 표현되는 (이를테면 문자열?) 데이터들을 객체 형태로 변경해서 관리하는 기법을 말합니다.
- 기본형 데이터로만 코드를 작성하게 되면, 나중에 해당 부분을 공통적으로 바꿀 부분이 생길 때 어려움이 많을 것인데
- 이런 데이터들을 묶어서 관리하는 객체로 관리했다면 변경사항 대응에 더 좋을 것 같습니다.
- 이를테면 `Enum`타입을 이용하는 것이 예시가 될 수 있을 것 같습니다.

## 임시 변수를 질의 함수로 바꾸기

- 표현식 작성을 통해서, 연산을 마친 값을 "임시로 만든 변수"에 저장해서 사용할 수 있습니다.
- 재사용하여 참조할 일이 있을 때 임시 변수에 값을 입력해 두고, 계산식의 작성을 줄이는 효과를 볼 수 있습니다.
- 그리고 이러한 계산식 자체를 함수로 추출하여 사용할 수도 있습니다.

## 클래스 추출하기

- 공통의 도메인을 갖는 데이터들을 클래스로 묶어 관리할 수가 있습니다.
- 그리고 이러한 과정을 반복하면서, 하나의 클래스가 너무 많은 정보들을 담게 될 때도 있는데  
  이런 경우에 하나의 클래스 내에서도, 서브클래스를 분리하는 작업이 필요할 수도 있습니다.

## 클래스 인라인하기

- 앞에서의 방법들과 마찬가지로, "추출하기"의 반대되는 개념이라고 생각하면 됩니다.
- 클래스 추출하기를 통해서 데이터를 여러 갈래로 나누다 보면, 오히려 불필요하게 분리되어 클래스 내에 아무런 기능이 없는 경우도 생기게 됩니다.
- 이런 경우에는 클래스로 분리되는 것이 오히려 간접 호출을 야기해, 코드의 이해만 어렵게 될 수도 있기 때문에 제거하는 것이 좋은 경우가 됩니다.

## 위임 숨기기

- 코드 실행부에서 알 필요 없는 참조 부분을 숨기는 리팩토링입니다.
- 명확히 와닿지가 않아 예시 코드로 대신하겠습니다.

```js
manager = aPerson.department.manager;

// ...

manager = aPerson.manager;

class Person {
  get manager() {
    return this.department.manager;
  }
}
```

## 중개자 제거하기

- 위의 위임 숨기기와 반대되는 작업입니다.
- 참조 부분을 숨기는 "중개자"를 제거하는 작업을 말합니다. 예시 코드는 반대가 될 것입니다.

```js
manager = aPerson.manager;

class Person {
  get manager() {
    return this.department.manager;
  }
}

// ...

manager = aPerson.department.manager;
```

## 알고리즘 교체하기

- 단순한 개념인데, 기존에 복잡한 구조의 코드를 간단한 구조의 코드로 바꿀 수 있다면, 교체하는 작업이다.
- 제 경우에는 조건 분기를 작성할 때 많이 알고리즘 교체를 하고 있습니다.

```js
if (userType === 'Anonymous' || userType === 'Company') {
  doSomething();
}
```

와 같은 코드를,

```js
switch (userType) {
  case 'Anonymous':
  case 'Company':
    doSomething();
    break;
  default:
    break;
}
```

또는

```js
if (['Anonymous', 'Company'].includes(userType)) {
  doSomething();
}
```

이런 형태로 알고리즘을 교체하곤 합니다.
